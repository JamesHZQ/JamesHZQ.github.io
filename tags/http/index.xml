<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>http on James He::blog</title>
    <link>https://JamesHZQ.github.io/tags/http/</link>
    <description>Recent content in http on James He::blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://JamesHZQ.github.io/tags/http/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>https原理</title>
      <link>https://JamesHZQ.github.io/2019/12/https%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://JamesHZQ.github.io/2019/12/https%E5%8E%9F%E7%90%86/</guid>
      <description>https实现原理 https在证书验证上用的非对称加密，内容传输上使用的是对称加密。
https通信过程 证书验证阶段：
 浏览器发起https请求 服务端返回https证书以及公钥 客户端验证证书是否合法，如果不合法则提示警告 当证书验证合法后，客户端在本地生成随机数 客户端通过公钥加密随机数，并把加密后的随机数传输到服务端。 服务端通过私钥解密得到随机数  数据传输阶段：
 服务端通过客户端传入的随机数构造加密算法，对返回的结果进行加密后传输。  为什么数据传输阶段使用对称加密？ 因为相比非对称加密/解密，对称加密解密的效率更高，而且在https协议下，服务端只拥有私钥，客户端只拥有私钥，一对公私钥只能实现单向的加解密，所以https在数据传输阶段使用对称加密。
为什么需要CA认证机构颁发证书？ http协议之所以不安全是因为在传输过程中，容易被监听者勾线监听、伪造服务器。引入https协议就是为了解决网络传输的安全性问题。若没有一个认证过的机构，任何人都可以制作证书，会带来“中间人攻击的问题”。
中间人攻击的过程如下：
 本地请求被劫持 (如 DNS 劫持等)，所有请求均发送到中间人的服务器。 中间人服务器返回中间人自己的证书。 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密。 中间人以客户端的请求内容再向正规网站发起请求。 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据。 中间人凭借与正规网站建立的对称加密算法对内容进行解密。 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输。 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密。  由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。
浏览器是如何确保 CA 证书的合法性?   证书包含的信息
颁发机构、公钥、公司、域名、有效期、指纹。。。
  证书的合法依据
 颁发证书的机构，需要经过认证，具有一定的权威性。 证书的信任制，权威机构要对颁发的证书进行信用背书 权威机构会对证书申请者进行信息审核    客户端浏览器验证证书的合法性
  验证域名，有效期等基本信息是否正确
  判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证。
  判断证书是否被篡改。需要与 CA 服务器进行校验。
  判断证书是否已吊销。通过 CRL(Certificate Revocation List 证书注销列表) 和 OCSP(Online Certificate Status Protocol 在线证书状态协议) 实现。</description>
    </item>
    
  </channel>
</rss>